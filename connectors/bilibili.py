"""
[GENERATED BY CURSOR]
A script to fetch the most recent videos from a Bilibili user.

This script uses the Bilibili API to retrieve video data from a specified user
by their mid (member ID). Videos are sorted by publication date (newest first).

This implementation uses curl to fetch the data. Standard implementation to fetch the data is likely to encounter rate limit, risk of being blocked, etc.

Ref: https://github.com/SocialSisterYi/bilibili-API-collect/blob/master/docs/video/collection.md#%E6%A0%B9%E6%8D%AE%E5%85%B3%E9%94%AE%E8%AF%8D%E6%9F%A5%E6%89%BE%E8%A7%86%E9%A2%91
Note: There is no description for the video using this API. To get the description, another API is needed. See: https://github.com/SocialSisterYi/bilibili-API-collect/blob/master/docs/video/info.md#%E8%A7%86%E9%A2%91%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF
"""

import json
import subprocess
import pandas as pd
from loguru import logger
from typing import Dict, Any


def get_user_videos(mid: int, page_size: int = 5, page_num: int = 1) -> Dict[str, Any]:
    """
    Fetch videos for a specific Bilibili user using curl.
    
    Args:
        mid: The Bilibili user ID
        page_size: Number of videos per page
        page_num: Page number to fetch
        
    Returns:
        Dict containing the API response
    """
    url = "https://api.bilibili.com/x/series/recArchivesByKeywords"
    
    # Build the curl command
    curl_cmd = [
        "curl", "-s", "-G", url,
        "--data-urlencode", f"mid={mid}", # mid is the user ID
        "--data-urlencode", "keywords=", # empty keywords means all videos from the user
        "--data-urlencode", f"ps={page_size}",
        "--data-urlencode", f"pn={page_num}",
        "--data-urlencode", "orderby=pubdate" # sort by publication date
    ]
    
    logger.info(f"Executing curl command: {' '.join(curl_cmd)}")
    
    try:
        # Execute the curl command and capture the output
        result = subprocess.run(curl_cmd, capture_output=True, text=True, check=True)
        
        if result.stderr:
            logger.warning(f"Curl stderr: {result.stderr}")
        
        # Parse the JSON response
        response = json.loads(result.stdout)
        
        logger.info(f"Response code: {response.get('code')}")
        logger.info(f"Response message: {response.get('message')}")
        return response
    
    except subprocess.CalledProcessError as e:
        logger.error(f"Curl command failed with exit code {e.returncode}")
        logger.error(f"Stderr: {e.stderr}")
        return {"code": -1, "message": f"Curl command failed: {e}", "data": {"archives": [], "page": {"total": 0}}}
    
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse JSON response: {e}")
        logger.error(f"Response content: {result.stdout[:500]}...")  # Print first 500 chars
        return {"code": -1, "message": f"JSON parsing failed: {e}", "data": {"archives": [], "page": {"total": 0}}}


def format_video_data(video: Dict[str, Any]) -> Dict[str, Any]:
    """
    Extract and format relevant video information.
    
    Args:
        video: Raw video data from API
        
    Returns:
        Dict with formatted video information
    """
    try:
        logger.info(f"Formatting video data: {video}")
        return {
            "aid": video.get("aid"),
            "bvid": video.get("bvid"),
            "title": video.get("title"),
            "published_at": pd.to_datetime(video.get("pubdate", 0), unit='s').date().isoformat() if video.get("pubdate") else None,
            "duration": video.get("duration"), # in seconds
            "stats": {
                "view_count": video.get("stat", {}).get("view", 0),
            },
            "thumbnail": video.get("pic"),
            "url": f"https://www.bilibili.com/video/{video.get('bvid')}"
        }
    except Exception as e:
        logger.error(f"Error formatting video data: {e}")
        logger.error(f"Video data: {json.dumps(video, indent=2, ensure_ascii=False)[:500]}...")
        return None


def main():
    mid = 946974 # 影视飓风
    limit = 1 # only get the latest video
    
    try:
        print(f"Fetching videos for user with mid={mid}, limit={limit}")
        
        # Initial request to get first page
        response = get_user_videos(mid, page_size=limit)
        
        if response.get("code") != 0:
            print(f"Error: {response.get('message', 'Unknown error')}")
            print(f"Full response: {json.dumps(response, indent=2, ensure_ascii=False)[:1000]}...")
            return
        
        # Check if data and archives exist in the response
        if "data" not in response:
            print(f"Error: 'data' field missing from response")
            print(f"Response keys: {response.keys()}")
            print(f"Full response: {json.dumps(response, indent=2, ensure_ascii=False)[:1000]}...")
            return
            
        if "archives" not in response["data"]:
            print(f"Error: 'archives' field missing from data")
            print(f"Data keys: {response['data'].keys()}")
            print(f"Full data: {json.dumps(response['data'], indent=2, ensure_ascii=False)[:1000]}...")
            return
            
        if "page" not in response["data"]:
            print(f"Error: 'page' field missing from data")
            print(f"Data keys: {response['data'].keys()}")
            print(f"Full data: {json.dumps(response['data'], indent=2, ensure_ascii=False)[:1000]}...")
            return
        
        videos = response["data"]["archives"]
        total_videos = response["data"]["page"].get("total", 0)
        
        print(f"Found {total_videos} videos for user (mid={mid})")
        print(f"Retrieved {len(videos)} videos in first page")
        
        # Format the data
        print("Formatting video data...")
        formatted_videos = [format_video_data(video) for video in videos]
        
        # print the formatted data
        print(formatted_videos)
            
    except Exception as e:
        print(f"Unexpected error: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main() 