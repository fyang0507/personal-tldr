"""
[GENERATED BY CURSOR]
Parsers package for website connectors.

This package provides different website parsing implementations and a unified
interface to access them via the `get_parser` factory function.
"""
import importlib
import inspect
from typing import Optional

from utils.logging_config import logger
from .base import BaseParser


def get_parser(parser_name: str) -> Optional[BaseParser]:
    """
    Dynamically imports a parser module and returns an instance of its BaseParser subclass.

    Tries to find a class named like '{ParserName}Parser' (e.g., GenericParser, Kr36Parser)
    or any other class within the module that is a subclass of BaseParser (excluding BaseParser itself).

    Args:
        parser_name: The name of the parser (e.g., "generic", "36kr").
                     This should match the Python module name in lowercase.
    Returns:
        An instance of the parser class, or None if an error occurs.
    """
    if not parser_name:
        logger.error("Parser name cannot be empty for dynamic loading.")
        return None
    
    module_name_lower = parser_name.lower()
    # Construct a conventional class name, e.g., "generic" -> "GenericParser", "my_cool_parser" -> "MyCoolParser"
    # For "36kr", we have a specific common naming convention Kr36Parser because python does not allow numbers at the start of a module name
    if module_name_lower == "36kr":
        conventional_class_name = "Kr36Parser"
    else:
        conventional_class_name = f"{module_name_lower.replace('_', ' ').title().replace(' ', '')}Parser"

    try:
        module_path = f"connectors.sources.website.parsers.{module_name_lower}"
        module = importlib.import_module(module_path)
        
        parser_class_to_instantiate = None

        # 1. Try conventional name first
        if hasattr(module, conventional_class_name):
            candidate_class = getattr(module, conventional_class_name)
            if inspect.isclass(candidate_class) and issubclass(candidate_class, BaseParser) and candidate_class is not BaseParser:
                parser_class_to_instantiate = candidate_class
                logger.info(f"Found parser class '{conventional_class_name}' by convention in module '{module_path}'.")

        # 2. If not found by convention, inspect module for any other BaseParser subclass
        if not parser_class_to_instantiate:
            for _, member in inspect.getmembers(module, inspect.isclass):
                if issubclass(member, BaseParser) and member is not BaseParser: # Ensure it's a concrete subclass
                    parser_class_to_instantiate = member
                    logger.info(f"Found BaseParser subclass '{member.__name__}' by inspection in '{module_path}'. Taking this one.")
                    break # Take the first concrete one found by inspection if conventional fails
        
        if parser_class_to_instantiate:
            logger.info(f"Instantiating parser: {parser_class_to_instantiate.__name__}")
            return parser_class_to_instantiate()
        else:
            logger.error(f"No suitable BaseParser subclass found in module '{module_path}' (tried convention: '{conventional_class_name}' and inspection).")
            return None
            
    except ImportError:
        logger.warning(f"Parser module for '{parser_name}' (tried path: '{module_path}') not found or caused an ImportError.")
        return None
    except Exception as e:
        logger.error(f"An unexpected error occurred while loading/instantiating parser '{parser_name}': {e}", exc_info=True)
        return None 