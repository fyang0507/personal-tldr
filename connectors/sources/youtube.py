"""
[GENERATED BY CURSOR]
YouTube Connector for fetching content from YouTube channels.

This module provides functionality to:
1. Check for updates from YouTube channels (first phase)
2. Retrieve cached content from YouTube channels (second phase)
3. Fetch channel IDs from channel names/handles
4. Filter videos based on duration requirements

The connector uses the YouTube Data API v3 and requires an API key.
See: https://developers.google.com/youtube/v3/docs/

Usage:
    from connectors.youtube import check_latest_updates, get_latest_update_details
    
    # Phase 1: Check for updates and cache data
    update_info = check_latest_updates("@channelname", api_key, duration_min=300)
    
    # Phase 2: Retrieve from cache when needed
    video_metadata = get_latest_update_details("@channelname")
    
    # Access video details
    video_title = video_metadata['title']
    video_url = video_metadata['url']
    video_duration = video_metadata['duration']
    view_count = video_metadata['stats']['view_count']

Note: The API key must have YouTube Data API v3 permissions enabled.
"""
from googleapiclient.discovery import build
from datetime import datetime
from dotenv import load_dotenv
import os
from utils.logging_config import logger
from typing import Dict, Any, Optional
from utils.connector_cache import ConnectorCache
import asyncio
from connectors.sources.base_source import SourceConnector

class YoutubeConnector(SourceConnector):
    """
    Connector for fetching content from YouTube channels.
    """
    def __init__(self, channel: str, duration_min: int = 300):
        """
        Initialize the YouTube connector with a channel name and duration minimum.
        
        Args:
            channel: The name of the YouTube channel to fetch content from.
            duration_min: The minimum duration of videos to fetch in seconds (to avoid shorts).
        """
        super().__init__(source_identifier=channel)
        self.channel = channel
        self.duration_min = duration_min
        self.cache = ConnectorCache()
        
        load_dotenv() # Ensure environment variables are loaded
        self.api_key = os.getenv('YOUTUBE_API_KEY')
        if not self.api_key:
            logger.critical("YOUTUBE_API_KEY not found in environment variables. YoutubeConnector cannot function.")
            raise ValueError("YOUTUBE_API_KEY not found in environment variables.")
            
        self.youtube_service = build('youtube', 'v3', developerKey=self.api_key)

    def _get_youtube_service(self):
        if not self.youtube_service:
            self.youtube_service = build('youtube', 'v3', developerKey=self.api_key)
        return self.youtube_service

    async def check_latest_updates(self) -> None:
        """
        Check for updates from a YouTube channel and cache the latest video metadata.
        Does not return any data; saves to cache.
        """
        cache_key = self._generate_cache_key()
        try:
            channel_id = self._get_channel_id_from_name(self.channel)
            if not channel_id:
                logger.error(f"Could not find channel ID for '{self.channel}'")
                return # Implicitly None
            
            metadata = self._get_latest_video_metadata(channel_id, self.duration_min)
            if not metadata:
                logger.warning(f"No suitable videos found for channel: {self.channel}")
                return # Implicitly None
            
            metadata["type"] = "youtube"
            metadata["channel"] = self.channel
            self.cache.save("youtube", cache_key, metadata) # Cache the full metadata
            logger.success(f"YouTube: Found and cached video '{metadata.get('title')}' (ID: {metadata.get('video_id')}) for channel {self.channel}")
            # No return value
        except Exception as e:
            logger.error(f"Error checking updates for YouTube channel '{self.channel}': {e}", exc_info=True)
            # No return value

    async def get_latest_update_details(self) -> Optional[Dict[str, Any]]:
        """
        Get full content and metadata for the latest YouTube video by loading from cache.
        Assumes check_latest_updates has populated the cache for this channel.
        """
        cache_key = self._generate_cache_key() # Cache key for the channel
        cached_channel_data = self.cache.load("youtube", cache_key)

        if cached_channel_data:
            logger.info(f"Returning cached data for YouTube channel {self.channel}, Video Title: {cached_channel_data.get('title')}")
            return cached_channel_data
        else:
            logger.warning(f"No cached data found for YouTube channel {self.channel} (cache key: {cache_key}). Run check_latest_updates first.")
            return None

    def _get_channel_id_from_name(self, channel_to_find: str) -> Optional[str]:
        """
        Get channel ID from channel name/handle
        """
        try:
            channel_processed = channel_to_find.lstrip('@')
            youtube = self._get_youtube_service()
            
            request = youtube.search().list(
                part='snippet',
                q=channel_processed,
                type='channel',
                maxResults=1
            ).execute()
            
            if not request['items']:
                logger.warning(f"No channel found for name: {channel_to_find}")
                return None
            
            channel_id = request['items'][0]['id']['channelId']
            
            channel_response = youtube.channels().list(
                part='snippet',
                id=channel_id
            ).execute()
            
            if channel_response['items']:
                channel_info = channel_response['items'][0]['snippet']
                if (channel_processed.lower() in channel_info.get('customUrl', '').lower() or 
                    channel_processed.lower() in channel_info['title'].lower()):
                    logger.info(f"Found channel ID: {channel_id} for channel: {channel_to_find}")
                    return channel_id
            
            logger.warning(f"Found a channel but it doesn't match the requested name: {channel_to_find}")
            return None
        except Exception as e:
            logger.error(f"Error finding channel ID for {channel_to_find}: {str(e)}")
            return None

    def _get_latest_video_metadata(self, channel_id: str, duration_min_val: int) -> Optional[Dict[str, Any]]:
        """
        Fetch metadata of the latest video from a YouTube channel
        """
        try:
            logger.info(f"Fetching videos for channel ID: {channel_id} with min duration: {duration_min_val}s")
            youtube = self._get_youtube_service()
            
            channel_response = youtube.channels().list(
                part='contentDetails',
                id=channel_id
            ).execute()
            
            if not channel_response.get('items'):
                logger.error(f"Channel ID {channel_id} not found or has no content details")
                return None
                
            uploads_playlist_id = channel_response['items'][0]['contentDetails']['relatedPlaylists']['uploads']
            logger.info(f"Found uploads playlist ID: {uploads_playlist_id}")
            
            max_results = 10 if duration_min_val > 0 else 1
            playlist_response = youtube.playlistItems().list(
                part='snippet',
                playlistId=uploads_playlist_id,
                maxResults=max_results
            ).execute()
            
            if not playlist_response['items']:
                logger.warning(f"No videos found in uploads playlist for channel ID: {channel_id}")
                return None
            
            video_to_return = None

            if duration_min_val <= 0:
                logger.info("No duration filter applied, taking the latest video")
                video_data_item = playlist_response['items'][0]
                video_id = video_data_item['snippet']['resourceId']['videoId']
                video_details_response = youtube.videos().list(
                    part='contentDetails,statistics,snippet',
                    id=video_id
                ).execute()
                if video_details_response['items']:
                    video_to_return = (video_data_item['snippet'], video_details_response['items'][0])
            else:
                videos_checked = 0
                for item in playlist_response['items']:
                    videos_checked += 1
                    video_data_snippet = item['snippet']
                    video_id = video_data_snippet['resourceId']['videoId']
                    
                    logger.info(f"Checking video ID: {video_id}, Title: {video_data_snippet['title']}")
                    
                    video_details_response = youtube.videos().list(
                        part='contentDetails,statistics,snippet',
                        id=video_id
                    ).execute()
                    
                    if not video_details_response['items']:
                        logger.warning(f"Could not retrieve details for video ID: {video_id}")
                        continue
                    
                    video_details_full = video_details_response['items'][0]
                    duration_str = video_details_full['contentDetails']['duration']
                    duration_seconds = 0
                    
                    time_parts = duration_str.replace('PT', '')
                    if 'H' in time_parts:
                        parts = time_parts.split('H')
                        duration_seconds += int(parts[0]) * 3600
                        time_parts = parts[1]
                    if 'M' in time_parts:
                        parts = time_parts.split('M')
                        duration_seconds += int(parts[0]) * 60
                        time_parts = parts[1]
                    if 'S' in time_parts:
                        duration_seconds += int(time_parts.replace('S', ''))
                    
                    logger.info(f"Video '{video_data_snippet['title']}' has duration: {duration_seconds}s (requirement: {duration_min_val}s)")
                    
                    if duration_seconds >= duration_min_val:
                        title = video_details_full['snippet']['title'].lower()
                        description = video_details_full['snippet']['description'].lower()
                        has_shorts_hashtag = '#shorts' in title or '#shorts' in description or '#short' in title or '#short' in description
                        
                        if has_shorts_hashtag:
                            logger.info(f"Video '{video_data_snippet['title']}' has required duration but contains #shorts hashtag, skipping.")
                        else:
                            logger.info(f"Found eligible video: '{video_data_snippet['title']}' with duration {duration_seconds}s")
                            video_to_return = (video_data_snippet, video_details_full)
                            break 
                else:
                    logger.warning(f"No video found with duration >= {duration_min_val} seconds after checking {videos_checked} videos")
                    return None
            
            if not video_to_return:
                logger.warning("Could not select a video to return.")
                return None

            video_data_snippet, video_details_full = video_to_return
            video_id = video_data_snippet['resourceId']['videoId']

            metadata = {
                'title': video_data_snippet['title'],
                'description': video_data_snippet['description'],
                'published_at': datetime.strptime(video_data_snippet['publishedAt'], '%Y-%m-%dT%H:%M:%SZ').isoformat(),
                'video_id': video_id,
                'url': f'https://www.youtube.com/watch?v={video_id}',
                'thumbnail_url': video_data_snippet['thumbnails']['default']['url'],
                'duration': video_details_full['contentDetails']['duration'],
                'stats': {
                    'view_count': video_details_full['statistics'].get('viewCount', 'N/A'),
                    'like_count': video_details_full['statistics'].get('likeCount', 'N/A'),
                    'comment_count': video_details_full['statistics'].get('commentCount', 'N/A'),
                }
            }
            
            logger.info(f"Successfully retrieved metadata for video: {video_id}")
            return metadata
            
        except Exception as e:
            logger.error(f"An error occurred while fetching video metadata: {str(e)}", exc_info=True)
            return None

async def main():
    channel = "@entreprenuership_opportunities"
    duration_min_val = 300

    try:
        connector = YoutubeConnector(channel, duration_min_val) # API_KEY is no longer passed
    except ValueError as e:
        logger.error(f"Failed to initialize YoutubeConnector: {e}")
        return

    logger.info(f"Demonstrating two-phase approach for YouTube channel: {channel}")
    
    logger.info("\n=== Phase 1: Check for updates (caches data) ===")
    await connector.check_latest_updates() # Call it, no return value to store
    
    # Optional: Add a small delay or a log message indicating cache *should* be populated.
    logger.info("Cache should now be populated if updates were found.")

    logger.info("\n=== Phase 2: Get content from cache/details ===")
    full_content = await connector.get_latest_update_details() # No argument passed
    
    if full_content:
        logger.info(f"Retrieved details: {full_content.get('title')}")
        logger.info(f"Duration: {full_content.get('duration', 'N/A')}")
        logger.info(f"URL: {full_content.get('url')}")
        logger.info(f"View Count: {full_content.get('stats', {}).get('view_count', 'N/A')}")
        logger.info(f"Comment Count: {full_content.get('stats', {}).get('comment_count', 'N/A')}")
    else:
        logger.error(f"Error retrieving full content details for channel: {channel_placeholder}. Was cache populated?")

if __name__ == "__main__":
    asyncio.run(main())
