"""
[GENERATED BY CURSOR]
This script effectively empties files in a GitHub Gist by replacing content with minimal data.

Usage:
1. Set your GIST_ID and GIST_TOKEN environment variables or modify this script
2. Run the script to empty filtered_results_* files while preserving current.json
"""

import os
import sys
from dotenv import load_dotenv
from utils.logging_config import logger
import requests
import time

def get_gist_files(gist_id, token):
    """
    Get all files in a GitHub Gist.
    
    Args:
        gist_id (str): The ID of the GitHub Gist.
        token (str): GitHub token for authentication.
        
    Returns:
        list: List of filenames in the gist.
    """
    headers = {"Authorization": f"Bearer {token}"} if token else {}
    response = requests.get(f"https://api.github.com/gists/{gist_id}", headers=headers)
    response.raise_for_status()
    gist_data = response.json()
    
    return list(gist_data["files"].keys())

def empty_gist_file(gist_id, token, filename):
    """
    Empty a file in a GitHub Gist (set its content to a single space).
    
    Args:
        gist_id (str): The ID of the GitHub Gist.
        token (str): GitHub token for authentication.
        filename (str): The name of the file to empty.
            
    Returns:
        bool: True if successful, False otherwise.
    """
    headers = {
        "Authorization": f"Bearer {token}",
        "Accept": "application/vnd.github.v3+json"
    }
    
    # Create a payload with minimal content
    files_data = {
        filename: {"content": " "}  # Single space - smallest valid content
    }
    
    payload = {
        "files": files_data
    }
    
    try:
        response = requests.patch(f"https://api.github.com/gists/{gist_id}", headers=headers, json=payload)
        response.raise_for_status()
        logger.info(f"Successfully emptied file: {filename}")
        return True
    except Exception as e:
        logger.error(f"Error emptying file {filename}: {str(e)}")
        return False

def main():
    # Load environment variables from .env file
    load_dotenv()
    
    # Get configuration from environment variables
    gist_id = os.getenv("GIST_ID")
    token = os.getenv("GIST_TOKEN")
    
    if not gist_id:
        logger.error("GIST_ID environment variable is required")
        sys.exit(1)
    
    if not token:
        logger.error("GIST_TOKEN environment variable is required")
        sys.exit(1)
    
    try:
        # List all files in the gist
        logger.info(f"Getting file list from gist {gist_id}...")
        file_list = get_gist_files(gist_id, token)
        
        # Filter the file list to only include files starting with filtered_results_
        filtered_results_files = [f for f in file_list if f.startswith("filtered_results_")]
        
        logger.info(f"Found {len(file_list)} total files in gist, {len(filtered_results_files)} filtered_results_* files:")
        for filename in filtered_results_files:
            logger.info(f"- {filename}")
        
        if not filtered_results_files:
            logger.warning("No filtered_results_* files found to empty")
            return
        
        # Confirm operation
        logger.info(f"\nYou are about to empty {len(filtered_results_files)} filtered_results_* files.")
        logger.info("Important: current.json will be preserved.")
        logger.info("Files will be processed one by one to avoid API limitations.")
        
        confirm = input("\nAre you sure you want to proceed? (yes/no): ")
        if confirm.lower() != 'yes':
            logger.info("Operation cancelled")
            return
        
        # Empty all files (replace content with a single space)
        logger.info("Emptying files (replacing content with minimal data)...")
        emptied_files = []
        
        for i, filename in enumerate(filtered_results_files):
            logger.info(f"Processing file {i+1}/{len(filtered_results_files)}: {filename}")
            success = empty_gist_file(gist_id, token, filename)
            if success:
                emptied_files.append(filename)
                
            # Add a small delay between requests to avoid rate limiting
            if i < len(filtered_results_files) - 1:
                time.sleep(1)
        
        if len(emptied_files) == len(filtered_results_files):
            logger.success(f"Successfully emptied all {len(emptied_files)} filtered_results_* files")
        else:
            logger.warning(f"Emptied {len(emptied_files)} out of {len(filtered_results_files)} files. Some files could not be processed.")
            
        # List remaining files that couldn't be emptied
        remaining = [f for f in filtered_results_files if f not in emptied_files]
        if remaining:
            logger.warning("Files that could not be emptied:")
            for filename in remaining:
                logger.warning(f"- {filename}")
        
    except Exception as e:
        logger.error(f"Error: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main() 