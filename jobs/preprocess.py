"""
[Generated by Cursor]
This script processes YouTube video metadata using OpenAI's API and prompts from preprocess.toml.
It cleans and structures the YouTube video metadata according to the specified format.
"""

import os
import json
import tomllib
from datetime import datetime
from openai import OpenAI
from dotenv import load_dotenv

def json_datetime_serializer(obj):
    """JSON serializer for objects not serializable by default json code"""
    if isinstance(obj, datetime):
        return obj.isoformat()
    raise TypeError ("Type %s not serializable" % type(obj))

def load_prompt_config():
    """Load the prompt configuration from the TOML file."""
    with open("prompts/preprocess.toml", "rb") as f:
        config = tomllib.load(f)
    return config["default"]["system"], config["default"]["model"]

def load_openai_client():
    """Load the OpenAI client."""
    load_dotenv()
    return OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def process_data(client, raw_data):
    """
    Process data using OpenAI API.
    
    Args:
        raw_data (dict): Raw video metadata
        
    Returns:
        dict: Processed and cleaned video metadata
    """    
    # Load prompt configuration
    system_prompt, model = load_prompt_config()
    
    # Prepare the user message with the raw data
    user_message = f"{json.dumps(raw_data, indent=2, default=json_datetime_serializer)}"
    
    # Call OpenAI API
    response = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_message}
        ],
        temperature=0.0
    )
    
    # Parse the response
    try:
        processed_data = json.loads(response.choices[0].message.content)
        return processed_data
    except json.JSONDecodeError as e:
        print(f"Error parsing OpenAI response: {e}")
        return None

def main():
    """Main function to process YouTube data."""
    # Get today's date in the format YYYY-MM-DD
    today = datetime.now().strftime("%Y-%m-%d")
    
    # Define file paths
    filtered_results_path = f"data/filtered_results_{today}.json"
    processed_results_path = f"data/processed_results_{today}.json"
    
    # Check if filtered results file exists
    if not os.path.exists(filtered_results_path):
        print(f"Error: {filtered_results_path} does not exist.")
        return
    
    # Load filtered results
    with open(filtered_results_path, 'r', encoding='utf-8') as f:
        filtered_results = json.load(f)
    
    client = load_openai_client()
    processed_results = []
    
    # Process each video in the filtered results
    for item in filtered_results:
        video_data = item['data']
        processed_data = process_data(client, video_data)
        if processed_data:
            processed_results.append(processed_data)
    
    # Save processed results
    with open(processed_results_path, 'w', encoding='utf-8') as f:
        json.dump(processed_results, f, ensure_ascii=False, indent=2)
    
    print(f"Processed {len(processed_results)} updates.")
    print(f"Results saved to {processed_results_path}")


if __name__ == "__main__":
    main()
